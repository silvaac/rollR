% Generated by roxygen2 (4.0.2): do not edit by hand
\name{applyRolling}
\alias{applyRolling}
\title{Similar to usual apply function but applies a function on a sliding window}
\usage{
applyRolling(x, fn, lookback = 100, step = 1, expand = FALSE,
  parallel = FALSE, fill = TRUE, ...)
}
\arguments{
\item{x}{input xts,matrix or data.frame}

\item{fn}{function to be applied}

\item{lookback}{is the number of periods we slide over the ts x}

\item{step}{is the number of period we move the lookback window}

\item{expand}{if true the window starts at lookback and increases at every step}

\item{parallel}{if true it will try to run in parallel in multiple cores or cluster.
Set up needs to be performed before calling applyRolling.
Default is parallel=FALSE. See snowfall package for set up.}

\item{fill}{TRUE (default) will return a series of dim equal to x filling the
values within the lookback with NA. FALSE returns data < dim(x)}

\item{...}{additional parameters for function fn}
}
\value{
time series (xts) of dim equal to x
}
\description{
Very powerfull function that applies a given function over a sliding window and
uses snowfall package to run in parallel. Checks shows considerable performance
increase (linear on the number of cores). If sfInit is not called it will run
the serial "applyRolling". Similar but faster that rollapplyr from xts.
The main difference is that the user has to explicitly handle input data with
more than one column (see example).
}
\examples{
x1 <- xts(1:100,Sys.Date()+1:100)
x2 <- merge(x1,xts(101:200,Sys.Date()+1:100))
# Using multiple CPUs with snowfall
\dontrun{
library(snowfall)
sfInit(parallel=TRUE,cpus=4)
sfLibrary(xts)
applyRolling(x1,fn=mean,lookback=2,parallel=TRUE)
applyRolling(x2,fn=function(x) colMeans(x),lookback=2,parallel=TRUE)
sfStop()
}
# Not parallel
applyRolling(x1,fn=mean,lookback=2)
applyRolling(x2,fn=function(x) colMeans(x),lookback=2)
}

